<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · FlexJuMP.jl - A Framework for Flexibility Analysis</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FlexJuMP.jl - A Framework for Flexibility Analysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../background/">Background</a></li><li><a class="toctext" href="../guide/">User Guide</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Module-1">Module</a></li><li><a class="toctext" href="#Functions/Methods-1">Functions/Methods</a></li><li><a class="toctext" href="#DataTypes-1">DataTypes</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/pulsipher/FlexJuMP.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><h2><a class="nav-anchor" id="Module-1" href="#Module-1">Module</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.FlexJuMP" href="#FlexJuMP.FlexJuMP"><code>FlexJuMP.FlexJuMP</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FlexJuMP</code></pre><p>A Julia package that implements a computational framework for quantifying and analyzing system flexibility.</p><p>The basic functionality emulates typical JuMP models to facilitate general computation of the flexibility index problem. Thus, basic functionality uses <a href="#FlexJuMP.FlexibilityModel"><code>FlexibilityModel</code></a>, <a href="#FlexJuMP.@randomvariable"><code>@randomvariable</code></a>, <a href="#FlexJuMP.@recoursevariable"><code>@recoursevariable</code></a>, <code>@variable</code>, <code>@constraint</code>, <a href="#FlexJuMP.setuncertaintyset"><code>setuncertaintyset</code></a>, and <code>solve</code>.</p><p><strong>Methods/Macros</strong></p><ul><li><a href="#FlexJuMP.FlexibilityModel"><code>FlexibilityModel</code></a></li><li><a href="#FlexJuMP.@randomvariable"><code>@randomvariable</code></a></li><li><a href="#FlexJuMP.@recoursevariable"><code>@recoursevariable</code></a></li><li><a href="#FlexJuMP.getflexibilitydata"><code>getflexibilitydata</code></a></li><li><a href="#FlexJuMP.setcovariance"><code>setcovariance</code></a></li><li><a href="#FlexJuMP.getcovariance"><code>getcovariance</code></a></li><li><a href="#FlexJuMP.getmean-Tuple{Model}"><code>getmean</code></a></li><li><a href="#FlexJuMP.setmean"><code>setmean</code></a></li><li><a href="#FlexJuMP.setuncertaintyset"><code>setuncertaintyset</code></a></li><li><a href="#FlexJuMP.ismeanfeasible"><code>ismeanfeasible</code></a></li><li><a href="#FlexJuMP.findcenteredmean"><code>findcenteredmean</code></a></li><li><a href="#FlexJuMP.getflexibilityindex"><code>getflexibilityindex</code></a></li><li><a href="#FlexJuMP.getsolutiontime"><code>getsolutiontime</code></a></li><li><a href="#FlexJuMP.getconfidencelevel"><code>getconfidencelevel</code></a></li><li><a href="#FlexJuMP.getactiveconstraints"><code>getactiveconstraints</code></a></li><li><a href="#FlexJuMP.rankinequalities"><code>rankinequalities</code></a></li><li><a href="#FlexJuMP.findstochasticflexibility"><code>findstochasticflexibility</code></a></li></ul></div></div></section><h2><a class="nav-anchor" id="Functions/Methods-1" href="#Functions/Methods-1">Functions/Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.FlexibilityModel" href="#FlexJuMP.FlexibilityModel"><code>FlexJuMP.FlexibilityModel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">FlexibilityModel(; [solver = JuMP.UnsetSolver()])</code></pre><p>Return a flexibility model object which extends a JuMP model object to contain <a href="#FlexJuMP.FlexibilityData"><code>FlexibilityData</code></a> and implement a custom solvehook. An appropriate solver should be specified in order solve the flexibility index problem. A solver capable of handling MIQCPs is required for ellipsoidal and 2-norm uncertainty sets otherwise a MILP solver can be used. This model is solved with <code>solve</code>, see <a href="#FlexJuMP.solvehook"><code>solvehook</code></a> for documention on the accepted keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>solver = JuMP.UnsetSolver()</code> The solver, should use an MIQCP, MINLP, or MILP solver as appropriate.</li></ul><pre><code class="language-julia">julia&gt; m = FlexibilityModel(solver = GurobiSolver())
Feasibility problem with:
 * 0 linear constraints
 * 0 variables
Solver is Gurobi</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.@randomvariable" href="#FlexJuMP.@randomvariable"><code>FlexJuMP.@randomvariable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@randomvariable(m, x, mean)</code></pre><p>Defines a random variable using <a href="#FlexJuMP.RandomVariable-Tuple{Model,Number,AbstractString}"><code>RandomVariable(m::Model, mean::Number, name::AbstractString)</code></a> and requires that a mean for the variable be provided. This can later be overwritten with <a href="#FlexJuMP.setmean"><code>setmean</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>x::Symbol</code> The variable name.</li><li><code>mean::Number</code> The variable mean</li></ul><pre><code class="language-julia">julia&gt; @randomvariable(m2, w, mean = 42)

julia&gt; @randomvariable(m2, ws[i = 1:4], mean = 42)
4-element Array{FlexJuMP.RandomVariable,1}:
 FlexJuMP.RandomVariable(Feasibility problem with:
 * 9 linear constraints
 * 89 variables

 julia&gt; @randomvariable(m2, ws[i = 1:4], mean = [1; 2; 3; 4][i])
 4-element Array{FlexJuMP.RandomVariable,1}:
  FlexJuMP.RandomVariable(Feasibility problem with:
  * 9 linear constraints
  * 96 variables</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.@recoursevariable" href="#FlexJuMP.@recoursevariable"><code>FlexJuMP.@recoursevariable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@recoursevariable(m, x)</code></pre><p>Defines a recourse variable using <a href="#FlexJuMP.RecourseVariable-Tuple{Model,AbstractString}"><code>RecourseVariable(m::Model, name::AbstractString)</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>x::Symbol</code> The variable name.</li></ul><pre><code class="language-julia">julia&gt; @recoursevariable(m2, d)

julia&gt; @recoursevariable(m2, ds[1:4])
4-element Array{FlexJuMP.RecourseVariable,1}:
 FlexJuMP.RecourseVariable(Feasibility problem with:
 * 9 linear constraints
 * 101 variables</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getflexibilitydata" href="#FlexJuMP.getflexibilitydata"><code>FlexJuMP.getflexibilitydata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getflexibilitydata(m::Model)</code></pre><p>Return the <a href="#FlexJuMP.FlexibilityData"><code>FlexibilityData</code></a> corresponding the flexibility model <code>m</code>. An error is thrown if <code>m</code> is a regular JuMP model.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getflexibilitydata(m)
FlexJuMP.FlexibilityData(JuMP.AbstractConstraint[], 0, Number[], AbstractString[], Int64[], 0, AbstractString[], Int64[], FlexJuMP.EllipsoidalSet(:Ellipsoid, false), Array{Number}(undef,0,0), nothing, Int64[], nothing)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.setcovariance" href="#FlexJuMP.setcovariance"><code>FlexJuMP.setcovariance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setcovariance(m::Model, covariance::Matrix)</code></pre><p>Specify the covariance matrix <code>covariance</code> to be stored in the flexibility model <code>m</code>. This method verifies that the matrix is symmetric positive semi-definite and writes it to <code>FlexibilityData.covariance</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>covariance::Matrix</code> The covariance matrix.</li></ul><pre><code class="language-julia">julia&gt; setcovariance(m, [2 1; 1 2])
2×2 Array{Int64,2}:
 2  1
 1  2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getcovariance" href="#FlexJuMP.getcovariance"><code>FlexJuMP.getcovariance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getcovariance(m::Model)</code></pre><p>Return the current covariance matrix in the flexibility model as stored in <code>FlexibilityData.covariance</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getcovariance(m)
4×4 Array{Number,2}:
 11.11   0.0    0.0    0.0
  0.0   11.11   0.0    0.0
  0.0    0.0   11.11   0.0
  0.0    0.0    0.0   11.11</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.setmean" href="#FlexJuMP.setmean"><code>FlexJuMP.setmean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setmean(m::Model, mean::Vector)</code></pre><p>Specify the mean corresponding to <code>FlexibilityData.RVmeans</code> stored in the flexibility model <code>m</code>. This method verifies that the length of the input <code>mean</code> matches the length of <code>FlexibilityData.RVmeans</code> before overwriting the current mean.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>mean::Vector</code> The means of the random variables.</li></ul><pre><code class="language-julia">setmean(m, [2.3; 5])
2-element Array{Float64,1}:
 2.3
 5.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getmean-Tuple{Model}" href="#FlexJuMP.getmean-Tuple{Model}"><code>FlexJuMP.getmean</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getmean(m::Model)</code></pre><p>Return the current mean vector in the flexibility model as stored in <code>FlexibilityData.RVmeans</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getmean(m)
4-element Array{Number,1}:
 620
 388
 583
 313</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getmean-Tuple{FlexJuMP.RandomVariable}" href="#FlexJuMP.getmean-Tuple{FlexJuMP.RandomVariable}"><code>FlexJuMP.getmean</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getmean(variable::RandomVariable)</code></pre><p>Return the mean corresponding to a particular <code>RandomVariable</code>. Currently this only accepts a single random variable and vector variables are not accepted directly.</p><p><strong>Arguments</strong></p><ul><li><code>variable::RandomVariable</code> The random variable name, must be a single variable.</li></ul><pre><code class="language-julia">julia&gt; getmean(T[1])
620</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.setuncertaintyset" href="#FlexJuMP.setuncertaintyset"><code>FlexJuMP.setuncertaintyset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setuncertaintyset(m::Model, uncertainty_set::Symbol, [attribute = nothing; only_positive::Bool = false])</code></pre><p>Specify the type of uncertainty set to be used and stored in <code>FlexibilityData.uncertainty_set</code> and provide the necessary attribute. An ellipsoidal uncertainty set can be specified with the <code>:Ellipsoid</code> symbol and the corresponding covariance matrix will need to input via <code>attribute</code> if it has not already been set with <a href="#FlexJuMP.setcovariance"><code>setcovariance</code></a>. A hyperbox uncertainty set is specified with the <code>:Hyperbox</code> symbol and corresponding negative/positive deviation vectors need to be inputed via <code>attribute</code> as a vector of vectors of the form <code>[[neg_dev]; [pos_dev]]</code>. Finally, a p-norm uncertainty set can be specified with the <code>:PNorm</code> symbol and providing the corresponding <code>p</code> value via <code>attribute</code> where <code>p</code> can equal <code>1</code>, <code>2</code>, or <code>Inf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>uncertainty_set::Symbol</code> The uncertainty set name.</li><li><code>attribute = nothing</code> The necessary atribute for the specified uncertainty set.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>only_positive::Bool = false</code> Indicate if the uncertainty set should be intersected with the set of all positive values.</li></ul><pre><code class="language-julia">julia&gt; setuncertaintyset(m, :Ellipsoid)

julia&gt; setuncertaintyset(m, :Ellipsoid, eye(4)* 11.11)

julia&gt; setuncertaintyset(m, :Hyperbox, [[ones(4)]; [ones(4)]])
FlexJuMP.HyperboxSet(:Hyperbox, Number[1.0, 1.0, 1.0, 1.0], Number[1.0, 1.0, 1.0, 1.0], false)

julia&gt; setuncertaintyset(m, :PNorm, 1)
FlexJuMP.PNormSet(:PNorm, 1, false)

julia&gt; setuncertaintyset(m, :PNorm, 2, only_positive = true)
FlexJuMP.PNormSet(:PNorm, 2, true)

julia&gt; setuncertaintyset(m, :PNorm, Inf)
FlexJuMP.PNormSet(:PNorm, Inf, false)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.ismeanfeasible" href="#FlexJuMP.ismeanfeasible"><code>FlexJuMP.ismeanfeasible</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ismeanfeasible(m::Model; [toler::Number = 1e-5, solver = Clp.ClpSolver()])</code></pre><p>Returns a <code>Bool</code> indicating if the mean stored in <code>FlexibilityData.RVmeans</code> is feasible, meaning that it lies inside the feasible region. This check is done using the so-called feasibility function.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>toler::Number = 1e-5</code> The numerical tolerance for checking the feasibility.</li><li><code>solver = Clp.ClpSolver()</code> The solver, any LP or NLP solver shoudl work.</li></ul><pre><code class="language-julia">julia&gt; ismeanfeasible(m)
true

julia&gt; ismeanfeasible(m, solver = GurobiSolver(OutputFlag = 0))
Academic license - for non-commercial use only
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.findcenteredmean" href="#FlexJuMP.findcenteredmean"><code>FlexJuMP.findcenteredmean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findcenteredmean(m::Model; [center::Symbol = :feasible, solver = Ipopt.IpoptSolver(print_level = 0), toler::Number = 1e-5, update_mean::Bool = false, only_positive::Bool = false])</code></pre><p>Returns a center point based on the analytic or feasible center. The result can overwrite the mean stored in <code>FlexibilityData.RVmeans</code> if desired. This is a wrapper function for <a href="#FlexJuMP.ComputeCenter"><code>ComputeCenter</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>center::Symbol = :feasible</code> Indicates the type of center, accepted arguments are <code>:feasible</code> and <code>:analytic</code>.</li><li><code>solver = Ipopt.IpoptSolver(print_level = 0)</code> The solver which must be an NLP solver for the analytic center.</li><li><code>toler::Number = 1e-5</code> The tolerance to check solution validity.</li><li><code>update_mean::Bool = false</code> Indicates if the computed center should overwrite <code>FlexibilityData.RVmeans</code>.</li><li><code>only_positive::Bool = false</code> Indicates if the center need by strictly positive.</li></ul><pre><code class="language-julia">julia&gt; findcenteredmean(m, only_positive = true)
4-element Array{Float64,1}:
 1684.74
   79.0718
  195.073
    0.0

julia&gt; findcenteredmean(m, center = :analytic, update_mean = true)
4-element Array{Float64,1}:
  898.125
 -507.214
  594.544
  317.23</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getflexibilityindex" href="#FlexJuMP.getflexibilityindex"><code>FlexJuMP.getflexibilityindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getflexibilityindex(m::Model)</code></pre><p>Return the current flexibility index in the flexibility model as stored in <code>FlexibilityData.flexibility_index</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getflexibilityindex(m)
3.5993764186390327</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getconfidencelevel" href="#FlexJuMP.getconfidencelevel"><code>FlexJuMP.getconfidencelevel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getconfidencelevel(m::Model)</code></pre><p>Return the confidence level provided that the flexibility model <code>m</code> has been solved with an ellipsoidal uncertainty set. This is equivalent to the quantile associated with the optimized uncertainty set. Note that this assumes a multivariate Gaussian distribution with mean <code>FlexibilityData.RVmeans</code> and covariance <code>FlexibilityData.covariance</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getconfidencelevel(m)
0.5370703369769008</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getsolutiontime" href="#FlexJuMP.getsolutiontime"><code>FlexJuMP.getsolutiontime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getsolutiontime(m::Model)</code></pre><p>Return the solution time to compute the flexibility index as stored in the flexibility model as stored in <code>FlexibilityData.solution_time</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getsolutiontime(m)
0.00199127197265625</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getactiveconstraints" href="#FlexJuMP.getactiveconstraints"><code>FlexJuMP.getactiveconstraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getactiveconstraints(m::Model)</code></pre><p>Return the current vector of active constraint indexes in the flexibility model as stored in <code>FlexibilityData.active_constraints</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><pre><code class="language-julia">julia&gt; getactiveconstraints(m)
2-element Array{Int64,1}:
 3
 6</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getvalue-Tuple{FlexJuMP.FlexibilityVariable}" href="#JuMP.getvalue-Tuple{FlexJuMP.FlexibilityVariable}"><code>JuMP.getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">JuMP.getvalue(v::FlexibilityVariable)</code></pre><p>Return the value of the a flexibility variable this is an extension of <code>JuMP.getvalue</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v::FlexibilityVariable</code> The flexibility variable.</li></ul><pre><code class="language-julia">julia&gt; getvalue(T)
4-element Array{Float64,1}:
 620.0
 388.0
 581.0
 319.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.rankinequalities" href="#FlexJuMP.rankinequalities"><code>FlexJuMP.rankinequalities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rankinequalities(m::Model; max_ranks::Int = 5, suppress_warnings::Bool = true, U::Int = 10000, diag::Bool = false, active_constr::Bool = false, real_recourse_dim::Int = -1, conic_δ::Bool = false)</code></pre><p>Returns ranking data in the form <code>Vector{Dict}</code> where each dictionary corresponds to a particular rank level and contains the optimal flexibility_index, active constraint indexes, and flexibility model. The function will iteratively solve copies of the flexibility model via <code>solve</code> where the prior active constraints are turned off in order rank the most limiting constraints. The user can specify the maximum number of rank levels and the flexibility index problem will be repeatedly solved until that maximum is acheived or the problem becomes unbounded, which occurs first.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>max_ranks::Int = 5</code> The maximum number of rank levels. 2</li><li><code>suppress_warnings::Bool = false</code> Indicates if solver warnings should be suppressed.</li><li><code>U::Union{Int, Float64} = 10000</code> The slack variable upper bound.</li><li><code>diag::Bool = false</code> Indicates whether or not to diagnonalize ellipsoidal uncertainty set (this is only active when an ellipsoidal set is used).</li><li><code>active_constr::Bool = false</code> Indicates if the optional active constraint should be used which enforces how many inequalities are active at the solution, this must be set to <code>true</code> for systems without control variables and/or contain state variables.</li><li><code>real_recourse_dim::Int = -1</code> The actual number of recourse variables in case state variables are included as recourse variables. This is mandatory if <code>active_constr = true</code> and no state variables are provided.</li><li><code>conic_δ::Bool = false</code> This should be set to <code>true</code> if a conic solver is used such as Pajarito.jl.</li></ul><pre><code class="language-julia">julia&gt; rankinequalities(m, active_constr = true)
2-element Array{Dict,1}:
 Dict{String,Any}(Pair{String,Any}(&quot;flexibility_index&quot;, 3.59938),Pair{String,Any}(&quot;model&quot;, Feasibility problem with:
 * 6 linear constraints
 * 6 variables
Solver is Pavito),Pair{String,Any}(&quot;active_constraints&quot;, [3, 6]))
 Dict{String,Any}(Pair{String,Any}(&quot;flexibility_index&quot;, 9.58983),Pair{String,Any}(&quot;model&quot;, Feasibility problem with:
 * 6 linear constraints
 * 6 variables
Solver is Pavito),Pair{String,Any}(&quot;active_constraints&quot;, [1, 5]))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.findstochasticflexibility" href="#FlexJuMP.findstochasticflexibility"><code>FlexJuMP.findstochasticflexibility</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findstochasticflexibility(m::Model; num_pts::Int = 10000, toler::Number = 1e-5, solver = Clp.ClpSolver(), only_positive::Bool = false, use_vulnerability_model::Bool = false, use_flexibility_index::Bool = false, seed::Int = -1)</code></pre><p>Returns the estimated stochastic flexibility index that is evaluated via Monte Carlo sampling. At default this estimation is carried out by evaluating the feasibility of each Monte Carlo sample. The samples are generating from a multivariate Gaussian distribution with mean <code>FlexibilityData.RVmeans</code> and covariance <code>FlexibilityData.covariance</code>. The vulnerability model also tests the feasibility of the samples, but does so in one large optimization problem instead of evaluating each sample indiviually. The optimized flexibility index can also be used to reduce the number of samples that need to be evaluated.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>num_pts::Int = 10000</code> Number of Monte Carlo samples.</li><li><code>toler::Number = 1e-5</code> The feasibility check tolerance.</li><li><code>solver = Clp.ClpSolver()</code> The solver, any LP or NLP solver should work.</li><li><code>only_positive::Bool = false</code> Indicates if only positive samples should be used.</li><li><code>use_vulnerability_model::Bool = false</code> Indicates if the vulnerability model should be used.</li><li><code>use_flexibility_index::Bool = false</code> Indicates if the optimal flexibility index should be used.</li><li><code>seed::Int = -1</code> Random seed for sample collection, any negative value will turn off the random seed.</li></ul><pre><code class="language-julia">julia&gt; findstochasticflexibility(m)
0.9687

julia&gt; findstochasticflexibility(m, use_vulnerability_model = true)
0.9705

julia&gt; findstochasticflexibility(m, num_pts = 5000, use_flexibility_index = true)
0.973</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.linearindex-Tuple{FlexJuMP.FlexibilityVariable}" href="#JuMP.linearindex-Tuple{FlexJuMP.FlexibilityVariable}"><code>JuMP.linearindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">JuMP.linearindex(v::FlexibilityVariable)</code></pre><p>Return the index of the a flexibility variable this is an extension of <code>JuMP.linearindex</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v::FlexibilityVariable</code> The flexibility variable, must be a single variable.</li></ul><pre><code class="language-julia">julia&gt; linearindex(Qc)
1</code></pre></div></div></section><h2><a class="nav-anchor" id="DataTypes-1" href="#DataTypes-1">DataTypes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.FlexibilityVariable" href="#FlexJuMP.FlexibilityVariable"><code>FlexJuMP.FlexibilityVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FlexibilityVariable &lt;: JuMP.AbstractJuMPScalar</code></pre><p>An abstract type to define new variable types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.RandomVariable" href="#FlexJuMP.RandomVariable"><code>FlexJuMP.RandomVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RandomVariable &lt;: FlexibilityVariable</code></pre><p>A DataType for random variables.</p><p><strong>Fields</strong></p><ul><li><code>m::Model</code> Flexibility model.</li><li><code>idx::Int</code> Index of variable in model.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.RecourseVariable" href="#FlexJuMP.RecourseVariable"><code>FlexJuMP.RecourseVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RecourseVariable &lt;: FlexibilityVariable</code></pre><p>A DataType for recourse variables.</p><p><strong>Fields</strong></p><ul><li><code>m::Model</code> Flexibility model.</li><li><code>idx::Int</code> Index of variable in model.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.FlexibilityExpr" href="#FlexJuMP.FlexibilityExpr"><code>FlexJuMP.FlexibilityExpr</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FlexibilityExpr &lt;: JuMP.GenericAffExpr</code></pre><p>A <code>GenericAffExpr</code> that contains random and/or recourse variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.FlexibilityConstraint" href="#FlexJuMP.FlexibilityConstraint"><code>FlexJuMP.FlexibilityConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FlexibilityConstraint &lt;: JuMP.AbstractConstraint</code></pre><p>A constraint that contains random and/or recourse variables.</p><p><strong>Fields</strong></p><ul><li><code>flex_expr::FlexibilityExpr</code> Constraint expression.</li><li><code>sense::Symbol</code> The cosntraint sense symbol <code>:(&lt;=)</code> or <code>:(&gt;=)</code> or <code>:(==)</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.AbstractUncertaintySet" href="#FlexJuMP.AbstractUncertaintySet"><code>FlexJuMP.AbstractUncertaintySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractUncertaintySet</code></pre><p>An abstract type to define new uncertainty set types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.EllipsoidalSet" href="#FlexJuMP.EllipsoidalSet"><code>FlexJuMP.EllipsoidalSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">EllipsoidalSet &lt;: AbstractUncertaintySet</code></pre><p>An ellipsoidal uncertainty set that will use the covariance matrix stored in <a href="#FlexJuMP.FlexibilityData"><code>FlexibilityData</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>name::Symbol</code> Name of the set which will be <code>:Ellipsoid</code>.</li><li><code>only_positive::Bool</code> An option to indicate if the set should be intersected with the set all positive numbers.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.HyperboxSet" href="#FlexJuMP.HyperboxSet"><code>FlexJuMP.HyperboxSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HyperboxSet &lt;: AbstractUncertaintySet</code></pre><p>A hyperbox uncertainty set whose nomimal dimensions are determined by <code>neg_dev</code> and <code>pos_dev</code>.</p><p><strong>Fields</strong></p><ul><li><code>name::Symbol</code> Name of the set which will be <code>:Hyperbox</code>.</li><li><code>neg_dev::Vector{Number}</code> A vector of the expected negative deviation of the random variables.</li><li><code>pos_dev::Vector{Number}</code> A vector of the expected positive deviation of the random variables.</li><li><code>only_positive::Bool</code> An option to indicate if the set should be intersected with the set all positive numbers.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.PNormSet" href="#FlexJuMP.PNormSet"><code>FlexJuMP.PNormSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PNormSet &lt;: AbstractUncertaintySet</code></pre><p>A p-norm based uncertainty set based on a bounded p-norm.</p><p><strong>Fields</strong></p><ul><li><code>name::Symbol</code> Name of the set which will be <code>:PNorm</code>.</li><li><code>p::Number</code> The value of p which can be 1, 2, or Inf.</li><li><code>only_positive::Bool</code> An option to indicate if the set should be intersected with the set all positive numbers.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.FlexibilityData" href="#FlexJuMP.FlexibilityData"><code>FlexJuMP.FlexibilityData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FlexibilityData</code></pre><p>A DataType for storing the data necessary to manage the bookkeeping of the flexibility variables (<code>RandomVariable</code> and <code>RecourseVariable</code>), the uncertainty set, and solution results.</p><p><strong>Fields</strong></p><ul><li><code>flexibility_constraints::Vector{JuMP.AbstractConstraint}</code> Constraints that involve flexibility variables.</li><li><code>numRVs::Int</code> The number of <code>RandomVariable</code> that have been added to the model.</li><li><code>RVmeans::Vector{Number}</code> The means corresponding to each <code>RandomVariable</code>.</li><li><code>RVnames::Vector{AbstractString}</code> The symbolic name of each <code>RandomVariable</code>.</li><li><code>RVcols::Vector{Int}</code> The index of each <code>RandomVariable</code>.</li><li><code>num_recourse_vars::Int</code> The number of <code>RecourseVariable</code> that have been added to the model.</li><li><code>recourse_names::Vector{AbstractString}</code> The symbolic name of each <code>RecourseVariable</code>.</li><li><code>recourse_cols::Vector{Int}</code> The index of each <code>RecourseVariable</code>.</li><li><code>uncertainty_set::AbstractUncertaintySet</code> The uncertainty set DataType with all of the set specfic attributes.</li><li><code>covariance::Matrix{Number}</code> The covariance matrix.</li><li><code>flexibility_index::Union{Nothing, Number}</code> The flexibility index result obtained from solving the flexibility model.</li><li><code>active_constraints::Vector{Int}</code> The indexes of the active inequality constraints at the solution of the flexibility model.</li><li>&#39;solution_time::Number&#39; The solution time in seconds.</li></ul></div></div></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.getuncertaintyset" href="#FlexJuMP.getuncertaintyset"><code>FlexJuMP.getuncertaintyset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getuncertaintyset(m::Model)</code></pre><p>Return the current uncertainty set datatype in the flexibility modelas stored in <code>FlexibilityData.uncertaintyset</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.solvehook" href="#FlexJuMP.solvehook"><code>FlexJuMP.solvehook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solvehook(m::Model; [suppress_warnings::Bool = false, U::Number = 10000, diag::Bool = false, active_constr::Bool = false, real_recourse_dim::Int = -1, conic_δ::Bool = false, inactives::Vector = []])</code></pre><p>Returns the solution status to solving the flexibility model <code>m</code>. This solvehook what <code>JuMP.solve(::Model)</code> for flexibility models. This solves the flexibility index problem using the variables and constraints specified in <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>suppress_warnings::Bool = false</code> Indicates if solver warnings should be suppressed.</li><li><code>U::Number = 10000</code> The slack variable upper bound.</li><li><code>diag::Bool = false</code> Indicates if the ellipsoidal uncertainty set is diagonalized (this is only active when an ellipsoidal set is used).</li><li><code>active_constr::Bool = false</code> Indicates if the optional active constraint should be used which enforces how many inequalities are active at the solution, this must be set to <code>true</code> for systems without control variables and/or contain state variables.</li><li><code>real_recourse_dim::Int = -1</code> The actual number of recourse variables in case state variables are included as recourse variables. This is mandatory if <code>active_constr = true</code> and no state variables are provided.</li><li><code>conic_δ::Bool = false</code> This should be set to <code>true</code> if a conic solver is used such as Pajarito.jl.</li><li><code>inactives::Vector = []</code> The indexes of inequality constraints that should be turned off.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.MakeInputDict" href="#FlexJuMP.MakeInputDict"><code>FlexJuMP.MakeInputDict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MakeInputDict(m::Model)</code></pre><p>Returns <code>input_dict::Dict</code> which contains the state space representation of the system equations stored in the flexibility model. The resulting <code>input_dict</code> is used by most of the flexibility analysis functions.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.AddSystemExpressions" href="#FlexJuMP.AddSystemExpressions"><code>FlexJuMP.AddSystemExpressions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AddSystemExpressions(m::Model, input_dict::Dict, [num_scenarios::Int = 0])</code></pre><p>Returns a vector of vectors where the first contains all the inequality expressions corresponding to the inequalities defined in <code>input_dict</code> and the second contains all of the equality expressions corresponding to the equalities defined in <code>input_dict</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>input_dict::Dict</code> Input dictionary as defined by <a href="#FlexJuMP.MakeInputDict"><code>MakeInputDict</code></a>.</li><li><code>num_scenarios::Int = 0</code> The number of scenerio subproblems, 0 turns off this feature.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.RandomVariable-Tuple{Model,Number,AbstractString}" href="#FlexJuMP.RandomVariable-Tuple{Model,Number,AbstractString}"><code>FlexJuMP.RandomVariable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">RandomVariable(m::Model, mean::Number, name::AbstractString)</code></pre><p>Return a <code>RandomVariable</code> DataType for given flexibility model <code>m</code> given the <code>mean</code> and the <code>name</code>. An anonymous JuMP variable is added directly to the flexibility model and its is appended to <code>FlexibilityData.RVcols</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>mean::Number</code> The variable mean.</li><li><code>name::AbstractString</code> The variable name.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.RecourseVariable-Tuple{Model,AbstractString}" href="#FlexJuMP.RecourseVariable-Tuple{Model,AbstractString}"><code>FlexJuMP.RecourseVariable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">RecourseVariable(m::Model, name::AbstractString)</code></pre><p>Return a <code>RecourseVariable</code> DataType for given flexibility model <code>m</code> given the <code>name</code>. An anonymous JuMP variable is added directly to the flexibility model and its is appended to <code>FlexibilityData.recourse_cols</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>name::AbstractString</code> The variable name.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,JuMP.GenericAffExpr{JuMP.GenericAffExpr{Float64,Variable},Union{RandomVariable, RecourseVariable}}}" href="#Base.show-Tuple{IO,JuMP.GenericAffExpr{JuMP.GenericAffExpr{Float64,Variable},Union{RandomVariable, RecourseVariable}}}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Base.show(io::IO, a::FlexibilityExpr)</code></pre><p>Extend <code>Base.show</code> to print flexibility expressions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.addconstraint-Tuple{Model,FlexJuMP.FlexibilityConstraint}" href="#JuMP.addconstraint-Tuple{Model,FlexJuMP.FlexibilityConstraint}"><code>JuMP.addconstraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">JuMP.addconstraint(m::Model, constr::FlexibilityConstraint)</code></pre><p>Extend the <code>JuMP.addconstraint</code> function to handle <code>FlexibilityConstraint</code> types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,FlexJuMP.FlexibilityConstraint}" href="#Base.show-Tuple{IO,FlexJuMP.FlexibilityConstraint}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">JuMP.show(io::IO,c::FlexibilityConstraint)</code></pre><p>Extend the <code>JuMP.show</code> function to handle <code>FlexibilityConstraint</code> types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.constructconstraint!-Tuple{JuMP.GenericAffExpr{JuMP.GenericAffExpr{Float64,Variable},Union{RandomVariable, RecourseVariable}},Symbol}" href="#JuMP.constructconstraint!-Tuple{JuMP.GenericAffExpr{JuMP.GenericAffExpr{Float64,Variable},Union{RandomVariable, RecourseVariable}},Symbol}"><code>JuMP.constructconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">JuMP.constructconstraint!(flex_aff::FlexibilityExpr, sense::Symbol)</code></pre><p>Extends <code>JuMP.constructconstraint!</code> for <code>FlexibilityExpr</code> types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlexJuMP.ComputeCenter" href="#FlexJuMP.ComputeCenter"><code>FlexJuMP.ComputeCenter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ComputeCenter(m::Model, center::Symbol, solver, toler::Number, only_positive::Bool)</code></pre><p>Returns a center point that can be used to replace the mean if desired.</p><p><strong>Arguments</strong></p><ul><li><code>m::Model</code> The flexibility model.</li><li><code>center::Symbol</code> Indicates the type of center, accepted arguments are <code>:feasible</code> and <code>:analytic</code>.</li><li><code>solver</code> The solver which must be an NLP solver for the analytic center.</li><li><code>toler::Number</code> The tolerance to check solution validity.</li><li><code>only_positive::Bool</code> Indicates if the center need by strictly positive.</li></ul></div></div></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#Base.show-Tuple{IO,JuMP.GenericAffExpr{JuMP.GenericAffExpr{Float64,Variable},Union{RandomVariable, RecourseVariable}}}"><code>Base.show</code></a></li><li><a href="#Base.show-Tuple{IO,FlexJuMP.FlexibilityConstraint}"><code>Base.show</code></a></li><li><a href="#FlexJuMP.AddSystemExpressions"><code>FlexJuMP.AddSystemExpressions</code></a></li><li><a href="#FlexJuMP.ComputeCenter"><code>FlexJuMP.ComputeCenter</code></a></li><li><a href="#FlexJuMP.FlexibilityModel"><code>FlexJuMP.FlexibilityModel</code></a></li><li><a href="#FlexJuMP.MakeInputDict"><code>FlexJuMP.MakeInputDict</code></a></li><li><a href="#FlexJuMP.findcenteredmean"><code>FlexJuMP.findcenteredmean</code></a></li><li><a href="#FlexJuMP.findstochasticflexibility"><code>FlexJuMP.findstochasticflexibility</code></a></li><li><a href="#FlexJuMP.getactiveconstraints"><code>FlexJuMP.getactiveconstraints</code></a></li><li><a href="#FlexJuMP.getconfidencelevel"><code>FlexJuMP.getconfidencelevel</code></a></li><li><a href="#FlexJuMP.getcovariance"><code>FlexJuMP.getcovariance</code></a></li><li><a href="#FlexJuMP.getflexibilitydata"><code>FlexJuMP.getflexibilitydata</code></a></li><li><a href="#FlexJuMP.getflexibilityindex"><code>FlexJuMP.getflexibilityindex</code></a></li><li><a href="#FlexJuMP.getmean-Tuple{FlexJuMP.RandomVariable}"><code>FlexJuMP.getmean</code></a></li><li><a href="#FlexJuMP.getmean-Tuple{Model}"><code>FlexJuMP.getmean</code></a></li><li><a href="#FlexJuMP.getsolutiontime"><code>FlexJuMP.getsolutiontime</code></a></li><li><a href="#FlexJuMP.getuncertaintyset"><code>FlexJuMP.getuncertaintyset</code></a></li><li><a href="#FlexJuMP.ismeanfeasible"><code>FlexJuMP.ismeanfeasible</code></a></li><li><a href="#FlexJuMP.rankinequalities"><code>FlexJuMP.rankinequalities</code></a></li><li><a href="#FlexJuMP.setcovariance"><code>FlexJuMP.setcovariance</code></a></li><li><a href="#FlexJuMP.setmean"><code>FlexJuMP.setmean</code></a></li><li><a href="#FlexJuMP.setuncertaintyset"><code>FlexJuMP.setuncertaintyset</code></a></li><li><a href="#FlexJuMP.solvehook"><code>FlexJuMP.solvehook</code></a></li><li><a href="#JuMP.addconstraint-Tuple{Model,FlexJuMP.FlexibilityConstraint}"><code>JuMP.addconstraint</code></a></li><li><a href="#JuMP.constructconstraint!-Tuple{JuMP.GenericAffExpr{JuMP.GenericAffExpr{Float64,Variable},Union{RandomVariable, RecourseVariable}},Symbol}"><code>JuMP.constructconstraint!</code></a></li><li><a href="#JuMP.getvalue-Tuple{FlexJuMP.FlexibilityVariable}"><code>JuMP.getvalue</code></a></li><li><a href="#JuMP.linearindex-Tuple{FlexJuMP.FlexibilityVariable}"><code>JuMP.linearindex</code></a></li><li><a href="#FlexJuMP.AbstractUncertaintySet"><code>FlexJuMP.AbstractUncertaintySet</code></a></li><li><a href="#FlexJuMP.EllipsoidalSet"><code>FlexJuMP.EllipsoidalSet</code></a></li><li><a href="#FlexJuMP.FlexibilityConstraint"><code>FlexJuMP.FlexibilityConstraint</code></a></li><li><a href="#FlexJuMP.FlexibilityData"><code>FlexJuMP.FlexibilityData</code></a></li><li><a href="#FlexJuMP.FlexibilityExpr"><code>FlexJuMP.FlexibilityExpr</code></a></li><li><a href="#FlexJuMP.FlexibilityVariable"><code>FlexJuMP.FlexibilityVariable</code></a></li><li><a href="#FlexJuMP.HyperboxSet"><code>FlexJuMP.HyperboxSet</code></a></li><li><a href="#FlexJuMP.PNormSet"><code>FlexJuMP.PNormSet</code></a></li><li><a href="#FlexJuMP.RandomVariable-Tuple{Model,Number,AbstractString}"><code>FlexJuMP.RandomVariable</code></a></li><li><a href="#FlexJuMP.RandomVariable"><code>FlexJuMP.RandomVariable</code></a></li><li><a href="#FlexJuMP.RecourseVariable-Tuple{Model,AbstractString}"><code>FlexJuMP.RecourseVariable</code></a></li><li><a href="#FlexJuMP.RecourseVariable"><code>FlexJuMP.RecourseVariable</code></a></li></ul><footer><hr/><a class="previous" href="../examples/"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
