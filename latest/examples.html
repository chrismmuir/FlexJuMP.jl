<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · FlexJuMP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FlexJuMP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="background.html">Background</a></li><li><a class="toctext" href="guide.html">User Guide</a></li><li class="current"><a class="toctext" href="examples.html">Examples</a><ul class="internal"><li><a class="toctext" href="#Heat-Exchanger-Network-1">Heat Exchanger Network</a></li><li><a class="toctext" href="#IEEE-14-Bus-Power-Network-1">IEEE-14 Bus Power Network</a></li></ul></li><li><a class="toctext" href="api.html">Library</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="examples.html">Examples</a></li></ul><a class="edit-page" href="https://github.com/pulsipher/FlexJuMP.jl/blob/master/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>This page provides two application examples that illustrate how FlexJuMP can be used and highlight some of its capabilities.</p><h2><a class="nav-anchor" id="Heat-Exchanger-Network-1" href="#Heat-Exchanger-Network-1">Heat Exchanger Network</a></h2><p>This is a common benchmark example used in flexibility analysis literature. The heat exchanger network is characterized according to the diagram below.</p><p><img src="images/HX_network.png" alt="hx_network"/></p><p>The system constraints are:</p><div>\[\begin{equation}
 \begin{aligned}
  -350 K - 0.67 Q_c + T_3 &amp;\leq 0 \\
  1388.5 K + 0.5 Q_c - 0.75 T_1 - T_3 - T_5 &amp;\leq 0 \\
  2044 K + Q_c - 1.5 T_1 - 2 T_3 - T_5 &amp;\leq 0 \\
  2830 K + Q_c - 1.5 T_1 - 2 T_3 - T_5 - 2 T_8 &amp;\leq 0 \\
  -3153 K - Q_c + 1.5 T_1 + 2 T_3 + T_5 + 3 T_8 &amp;\leq 0
 \end{aligned}
\end{equation}\]</div><p>where <span>$T_1$</span>, <span>$T_3$</span>, <span>$T_5$</span>, and <span>$T_8$</span> denote the Gaussian parameters and <span>$Q_c$</span> denotes the recourse variable.  The mean and covariance matrix are given by:</p><div>\[\begin{equation}
 \bar{\boldsymbol{\theta}} =
 \begin{bmatrix}
   620 \\ 388 \\ 583 \\ 313
   \end{bmatrix} K
   \ \ \ \ \ \
   V_{\boldsymbol{\theta}} =
   \begin{bmatrix}
   11.11 &amp; 0 &amp; 0 &amp; 0 \\
   0 &amp; 11.11 &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; 11.11 &amp; 0 \\
   0 &amp; 0 &amp; 0 &amp; 11.11
 \end{bmatrix} K^2
\end{equation}\]</div><p>The parameter variance <span>$\sigma_i^2$</span> is taken to be <span>$11.11 K^2$</span> which corresponds to <span>$\bar{\theta}_i \pm 3 \sigma_i$</span>, where <span>$3 \sigma_i$</span> is equated to <span>$10 K$</span> in accordance to the <span>$\pm 10 K$</span> variations historically reported.</p><p>Now that we have formalized the system parameters and equations we can setup and solve a flexibility model. Let&#39;s first setup the model using a hyperbox uncertainty set.</p><pre><code class="language-">using FlexJuMP, JuMP
using Gurobi

# Setup the uncertainty set parameters
means = [620; 388; 583; 313]
covar = [11.11 0 0 0; 0 11.11 0 0; 0 0 11.11 0; 0 0 0 11.11]
box_dev = ones(4) * 10

# Setup the model
m = FlexibilityModel(solver = GurobiSolver(OutputFlag = 0))

# Define variables
@randomvariable(m, T[i = 1:4], mean = means[i])
@recoursevariable(m, Qc)

# Define the constraints
@constraint(m, -350 - 0.67Qc + T[2] &lt;= 0.0)
@constraint(m, 1388.5 + 0.5Qc - 0.75T[1] - T[2] - T[3] &lt;= 0.0)
@constraint(m, 2044 + Qc - 1.5T[1] - 2T[2] - T[3] &lt;= 0.0)
@constraint(m, 2830 + Qc - 1.5T[1] - 2T[2] - T[3] - 2T[4] &lt;= 0.0)
@constraint(m, -3153 - Qc + 1.5T[1] + 2T[2] + T[3] + 3T[4] &lt;= 0.0)

# Define the uncertainty set
setuncertaintyset(m, :Hyperbox, [[box_dev]; [box_dev]]);</code></pre><p>Before solving let&#39;s verify that the means provide a feasible nominal point.</p><pre><code class="language-">isvalid = ismeanfeasible(m)</code></pre><p>Since the mean is feasible we can proceed to solve <code>m</code> using all the default settings and then extract the solution data.</p><pre><code class="language-"># Solve
  status = solve(m)

  if status == :Optimal
      # Retrieve optimized data
      flexibility_index = getflexibilityindex(m)
      temperatures = getvalue(T)
      cooling = getvalue(Qc)
      actives = getactiveconstraints(m)

      # Print the results
      print(&quot;Flexibility Index:     &quot;, round(flexibility_index, 4), &quot;\n&quot;)
      print(&quot;Critical Temperatures: &quot;, round.(temperatures, 2), &quot;\n&quot;)
      print(&quot;Critical Cooling:      &quot;, round(cooling, 2), &quot;\n&quot;)
      print(&quot;Active Constraints:    &quot;, actives)
  end</code></pre><p>This result indicates that the largest feasible hyperbox uncertainty set is given by 50% of its nominal scale, meaning only <span>$\pm 5 K$</span> variations are feasible. Let&#39;s now specify the covariance matrix so we can estimate the stochastic flexibility index.</p><pre><code class="language-">setcovariance(m, covar)
SF = findstochasticflexibility(m, use_vulnerability_model = true)</code></pre><p>Now let&#39;s change the uncertainty set to be ellipsoidal and resolve. Notice that we don&#39;t need to provide the covariance as an attribute because we already set it with <code>setcovariance</code>. We also will enable diagonalization of the ellipsoidal constraint by using the keyword argument <code>diag:Bool</code>.</p><pre><code class="language-"># Change the uncertainty set
setuncertaintyset(m, :Ellipsoid)

# Solve
  status = solve(m, diag = true)

  if status == :Optimal
      # Retrieve optimized data
      flexibility_index = getflexibilityindex(m)
      temperatures = getvalue(T)
      cooling = getvalue(Qc)
      actives = getactiveconstraints(m)
      conf_lvl = getconfidencelevel(m)

      # Print the results
      print(&quot;Flexibility Index:     &quot;, round(flexibility_index, 4), &quot;\n&quot;)
      print(&quot;Confidence Level:      &quot;, round(conf_lvl, 4), &quot;\n&quot;)
      print(&quot;Critical Temperatures: &quot;, round.(temperatures, 2), &quot;\n&quot;)
      print(&quot;Critical Cooling:      &quot;, round(cooling, 2), &quot;\n&quot;)
      print(&quot;Active Constraints:    &quot;, actives)
  end</code></pre><p>We note that the confidence level provides a lower bound on the stochastic flexibility index as we expect.</p><h2><a class="nav-anchor" id="IEEE-14-Bus-Power-Network-1" href="#IEEE-14-Bus-Power-Network-1">IEEE-14 Bus Power Network</a></h2><p>We now consider the IEEE 14-node power network. Which we model by performing balances at each node <span>$n \in \mathcal{C}$</span> and enforcing capacity constraints on the arcs <span>$a_k, k \in \mathcal{A},$</span> and on the suppliers <span>$s_b, b \in \mathcal{S}$</span>. The demands <span>$d_m, m \in \mathcal{D},$</span> are assumed to be the uncertain parameters. The flexibility index problem those seek to identify the largest set of simultaneous demand withdrawals that the system can tolerate. The deterministic network model is given by:</p><div>\[\begin{equation}
	\sum_{k \in \mathcal{A}_n^{rec}} a_k - \sum_{k \in \mathcal{A}_n^{snd}} a_k + \sum_{b \in \mathcal{S}_n} s_b - \sum_{m \in \mathcal{D}_n} d_m = 0, \ \ \ n \in \mathcal{C}
\end{equation}\]</div><div>\[\begin{equation}
	-a_k^C \leq a_k \leq a_k^C, \ \ \ k \in \mathcal{A}
\end{equation}\]</div><div>\[\begin{equation}
	0 \leq s_b \leq s_b^C, \ \ \ b \in \mathcal{S}
\end{equation}\]</div><p>where <span>$\mathcal{A}_n^{rec}$</span> denotes the set of receiving arcs at node <span>$n$</span>, <span>$\mathcal{A}_n^{snd}$</span> denotes the set of sending arcs at <span>$n$</span>, <span>$\mathcal{S}_n$</span> denotes the set of suppliers at <span>$n$</span>, <span>$\mathcal{D}_n$</span> denotes the set of demands at <span>$n$</span>, <span>$a_k^C$</span> are the arc capacities, and <span>$s_b^C$</span> are the supplier capacities.</p><p>This test case does not provide arc capacities so we enforce a capacity of 100 for all the arcs. A schematic of this system is provided below.</p><p><img src="images/ieee14_diagram.png" alt="ieee14"/></p><p>This system is subjected to a total of 10 uncertainty disturbances (the network demands). The demands are assumed to be <span>$\boldsymbol{\theta} \sim \mathcal{N}(\bar{\boldsymbol{\theta}}, V_{\boldsymbol{\theta}})$</span>, where <span>$\bar{\boldsymbol{\theta}} = \bar{\boldsymbol{\theta}}_{fc}$</span> and <span>$V_{\boldsymbol{\theta}} = 1200 \mathbb{I}$</span>. We select the set <span>$T_{\infty}(\delta)$</span>. Thus, we setup flexibility model.</p><pre><code class="language-">using FlexJuMP, JuMP
using Gurobi, Pavito, Ipopt

# Set the dimensions
n_gens = 5
n_lines = 20
n_dems = 11

# Setup the uncertainty set parameters
covar = eye(n_dems) * 1200.

# Specify the network details
line_cap = 100
gen_cap = [332; 140; 100; 100; 100]

# Setup the model
m = FlexibilityModel(solver = PavitoSolver(mip_solver = GurobiSolver(OutputFlag = 0),
                     cont_solver = IpoptSolver(print_level = 0), log_level = 0,
                     mip_solver_drives = false))

# Define variables
@randomvariable(m, d[i = 1:n_dems], mean = 0) # Temperarily set the mean to 0
@recoursevariable(m, a[1:n_lines])
@recoursevariable(m, g[1:n_gens])

# Set the line capacity constraints
@constraint(m, [line = 1:n_lines], -line_cap &lt;= a[line])
@constraint(m, [line = 1:n_lines], a[line] &lt;= line_cap)

# Set the generator capacity constraints
@constraint(m, [gen = 1:n_gens], 0.0 &lt;= g[gen])
@constraint(m, [gen = 1:n_gens], g[gen] &lt;= gen_cap[gen])

# Set the node balance constraints
@constraint(m, g[1] - a[1] - a[6] == 0)
@constraint(m, a[1] + g[2] - sum(a[i] for i = [2; 4; 5]) - d[1] == 0)
@constraint(m, g[3] + a[2] - a[3] - d[2] == 0)
@constraint(m, sum(a[i] for i = [3; 4; 8]) - sum(a[i] for i = [7; 11]) - d[3] == 0)
@constraint(m, sum(a[i] for i = [5; 6; 7; 12]) - d[4] == 0)
@constraint(m, g[4] + sum(a[i] for i = [16; 18]) - sum(a[i] for i = [12; 19]) - d[5] == 0)
@constraint(m, a[9] - sum(a[i] for i = [8; 10]) == 0)
@constraint(m, g[5] - a[9] == 0)
@constraint(m, sum(a[i] for i = [10; 11]) - sum(a[i] for i = [13; 14]) - d[6] == 0)
@constraint(m, sum(a[i] for i = [13; 20]) - d[7] == 0)
@constraint(m, a[19] - a[20] - d[8] == 0)
@constraint(m, a[17] - a[18] - d[9] == 0)
@constraint(m, a[15] - sum(a[i] for i = [16; 17]) - d[10] == 0)
@constraint(m, a[14] - a[15] - d[11] == 0)

# Define the covariance and the uncertainty set
setcovariance(m, covar)
setuncertaintyset(m, :PNorm, Inf);</code></pre><p>The flexibility model <code>m</code> is now defined, so now we compute the feasible center and solve <code>m</code>.</p><pre><code class="language-"># Compute a center to replace the mean if desired
new_mean = findcenteredmean(m, center = :feasible, solver = GurobiSolver(OutputFlag = 0),
                            update_mean = true)
updated_mean = getmean(m)

# Solve
status = solve(m)

if status == :Optimal
    # Retrieve optimized data
    flexibility_index = getflexibilityindex(m)
    lines = getvalue(a)
    generators = getvalue(g)
    demands = getvalue(d)
    actives = getactiveconstraints(m)

    # Print the results
    print(&quot;Flexibility Index:   &quot;, round(flexibility_index, 4), &quot;\n&quot;)
    print(&quot;Active Constraints:  &quot;, actives)
end</code></pre><p>Now we will use the <code>rankinequalities</code> function to obtain a ranking of the most limiting components.</p><pre><code class="language-"># Rank the inequality constraints
rank_data = rankinequalities(m, max_ranks = 3)</code></pre><p>Thus, now we can identify which lines and generators most limit system flexibility. We also observe how the flexibility index increases with each rank level as is expected.</p><footer><hr/><a class="previous" href="guide.html"><span class="direction">Previous</span><span class="title">User Guide</span></a><a class="next" href="api.html"><span class="direction">Next</span><span class="title">Library</span></a></footer></article></body></html>
