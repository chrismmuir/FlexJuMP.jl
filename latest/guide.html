<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · FlexJuMP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FlexJuMP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="background.html">Background</a></li><li class="current"><a class="toctext" href="guide.html">User Guide</a><ul class="internal"><li><a class="toctext" href="#Model-Definition-and-Setup-1">Model Definition and Setup</a></li><li><a class="toctext" href="#Pre-Solution-Methods-1">Pre-Solution Methods</a></li><li><a class="toctext" href="#Model-Solution-1">Model Solution</a></li><li><a class="toctext" href="#Post-Solution-Methods-1">Post-Solution Methods</a></li><li><a class="toctext" href="#Analysis-Methods-1">Analysis Methods</a></li></ul></li><li><a class="toctext" href="examples.html">Examples</a></li><li><a class="toctext" href="api.html">Library</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="guide.html">User Guide</a></li></ul><a class="edit-page" href="https://github.com/pulsipher/FlexJuMP.jl/blob/master/docs/src/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><p>This page provides an overview of how to use FlexJuMP to analyze system flexibility. Detailed explanations on the syntax of each method/function and datatype is provided in <a href="api.html#Library-1">Library</a>.</p><p>The package needs to be loaded along with <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP.jl</a> in the usual manner:</p><div><pre><code class="language-julia">using FlexJuMP, JuMP</code></pre></div><h2><a class="nav-anchor" id="Model-Definition-and-Setup-1" href="#Model-Definition-and-Setup-1">Model Definition and Setup</a></h2><h3><a class="nav-anchor" id="Flexibility-Model-Definition-1" href="#Flexibility-Model-Definition-1">Flexibility Model Definition</a></h3><p>The flexibility model is defined with the <a href="api.html#FlexJuMP.FlexibilityModel"><code>FlexibilityModel</code></a> function and the solver that will be used to solve the flexibility index problem should be specified.</p><pre><code class="language-">using Gurobi
m = FlexibilityModel(solver = GurobiSolver(OutputFlag = 0))</code></pre><p>Flexibility models are JuMP models that have been extended to include information needed for flexibility analysis and incorporate <a href="api.html#FlexJuMP.solvehook"><code>solvehook</code></a> which solves the flexibility index problem.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A solver that is capable of solving MIQCPs if an ellipsoidal or 2-norm uncertainty set must be used. Otherwise, an MILP solver will work.</p></div></div><h3><a class="nav-anchor" id="Variable-Definition-1" href="#Variable-Definition-1">Variable Definition</a></h3><p>Now we can add variables to <code>m</code> using the <a href="api.html#FlexJuMP.@randomvariable"><code>@randomvariable</code></a> macro for random variables, the <a href="api.html#FlexJuMP.@recoursevariable"><code>@recoursevariable</code></a> macro for recourse/control variables, the standard <code>@variable</code> JuMP macro to add state variables.</p><div></div><pre><code class="language-julia">means = [620; 388; 583; 313]
@randomvariable(m, T[i = 1:4], mean = means[i])
@recoursevariable(m, Qc)
@variable(m, x)</code></pre><p>In applications where it is not clear what variables are state/recourse variables, all the nonrandom variables can simply be defined with the <code>@recoursevariable</code> macro. The <code>@randomvariable</code> and <code>@recoursevariable</code> macros can define single variables and/or arrays of variables if we append brackets to the variable as is done in JuMP. For example</p><pre><code class="language-julia">@recoursevariable(m, y[1:N, 1:M])</code></pre><p>will create an <code>N</code> by <code>M</code> array of recourse variables.</p><p>However, these macros currently don&#39;t support specification of variable upper/lower bounds in contrast to the traditional JuMP syntax. Similarly, bounds added via the <code>@variable</code> macro will be ignored.</p><p>Please note that the <code>@randomvariable</code> macro requires that a mean be provided for each random variable. This can be done in the three following ways:</p><pre><code class="language-julia">@randomvariable(m, z], mean = 42) # create one variable with mean 42
@randomvariable(m, z[i = 1:N], mean = means[i]) # assign means via a predefined vector
@randomvariable(m, z[i = 1:N], mean = 42) # assign the same mean to each variable</code></pre><p>The vector containing the means of all the random variables can later be changed with the <a href="api.html#FlexJuMP.setmean"><code>setmean</code></a> function.</p><h3><a class="nav-anchor" id="Constraint-Definition-1" href="#Constraint-Definition-1">Constraint Definition</a></h3><p>Now we can add constraints to <code>m</code> via the <code>@constraint</code> macro as we normally would with typical JuMP models.</p><pre><code class="language-">@constraint(m, -100 - 0.67Qc + 2T[2] + x &lt;= 0.0)
@constraint(m, -250 - T[2] == x)
@constraint(m, 0.5Qc - 0.75T[1] - T[2] - T[3] &lt;= -1388.5)
@constraint(m, -Qc + 1.5T[1] + 2T[2] + T[3] &gt;= 2044)
@constraint(m, Qc - 1.5T[1] - 2T[2] - T[3] - 2T[4] &lt;= -2830)
@constraint(m, -Qc + 1.5T[1] + 2T[2] + T[3] + 3T[4] &lt;= 3153)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Currently, only linear constraints can be used with FlexJuMP.</p></div></div><h3><a class="nav-anchor" id="Uncertainty-Set-Definition-1" href="#Uncertainty-Set-Definition-1">Uncertainty Set Definition</a></h3><p>Now we can specify which uncertainty set we would like to use. This is done via the <a href="api.html#FlexJuMP.setuncertaintyset"><code>setuncertaintyset</code></a> function. One of the 5 uncertainty set types described in the <a href="background.html#Uncertainty-Set-Characterization-1">Uncertainty Set Characterization</a> section can specified. For a flexibility model <code>m</code>, the set type is specified in the second argument with one of the following symbols: <code>:Ellipsoid</code>, <code>:Hyperbox</code>, or <code>:PNorm</code>. The third argument should contain whatever attribute is needed for that uncertainty set type. Continuing the example above we would define an ellipsoidal set</p><pre><code class="language-">covar = [11.11 0 0 0; 0 11.11 0 0; 0 0 11.11 0; 0 0 0 11.11]
setuncertaintyset(m, :Ellipsoid, covar)</code></pre><p>where the required attribute is the covariance matrix. Note that the covariance matrix must be symmetric positive semi-definite dimensionality that matches the number of random variables.</p><p>The other sets could have instead been defined by:</p><pre><code class="language-julia">box_dev = [10; 10; 10; 10]
setuncertaintyset(m, :Hyperbox, [[box_dev]; [box_dev]])
setuncertaintyset(m, :PNorm, 1)
setuncertaintyset(m, :PNorm, 2)
setuncertaintyset(m, :PNorm, Inf)</code></pre><p>The hyperbox set requires that a vector of two vectors that correspond to the negative and positive deviations be provided (these deviations are explained in <a href="background.html#Uncertainty-Set-Characterization-1">Uncertainty Set Characterization</a>). The p-norm sets required that the value of <code>p</code> be provided which can <code>1</code>, <code>2</code>, or <code>Inf</code>. A summary of the sets and their required inputs is shown below.</p><table><tr><th>Uncertainty Set Type</th><th>Symbol</th><th>Attribute</th></tr><tr><td>Ellipsoidal</td><td><code>:Ellipsoid</code></td><td><code>covariance::Matrix</code></td></tr><tr><td>Hyperbox</td><td><code>:Hyperbox</code></td><td><code>[[neg_dev]; [pos_dev]]::Vector{Vector}</code></td></tr><tr><td>P-Norm</td><td><code>:PNorm</code></td><td><code>1</code>, <code>2</code>, or <code>Inf</code></td></tr></table><p>The <code>setuncertaintyset</code> function also accepts the keyword argument <code>only_positive::Bool</code> to indicate if the uncertainty set should be intersected with the set of all positive real numbers <span>$\mathbb{R}_+^{n_{\theta}}$</span>. For example, to define the set <span>$T_{ellip}(\delta) \cap \mathbb{R}_+^{n_{\theta}}$</span> we would call</p><pre><code class="language-julia">setuncertaintyset(m, :Ellipsoid, covar, only_positive = true)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>By default the uncertainty set is taken to be ellipsoidal. Thus, one need not call <code>setuncertaintyset</code> if an ellipsoidal set is desired, but the the covariance matrix must still be specified via the <a href="api.html#FlexJuMP.setcovariance"><code>setcovariance</code></a> function.</p></div></div><h2><a class="nav-anchor" id="Pre-Solution-Methods-1" href="#Pre-Solution-Methods-1">Pre-Solution Methods</a></h2><p>This section will outline methods/functions that are geared to be called before <code>m</code> is solved, but can still be applied after it is solved.</p><h3><a class="nav-anchor" id="Mean-Extraction/Manipulation-1" href="#Mean-Extraction/Manipulation-1">Mean Extraction/Manipulation</a></h3><p>The mean corresponding to a particular random variable can be extracted via the <a href="api.html#FlexJuMP.getmean-Tuple{FlexJuMP.RandomVariable}"><code>getmean(variable::RandomVariable)</code></a> method. Note that this only works for individual variables and that arrays of random variables are not valid input.</p><pre><code class="language-">variable_mean = getmean(T[2])</code></pre><p>The means of all the random variables in <code>m</code> can be extracted via the <a href="api.html#FlexJuMP.getmean-Tuple{JuMP.Model}"><code>getmean(m::Model)</code></a> method. For the current example we have</p><pre><code class="language-">current_mean = getmean(m)</code></pre><p>The means of all the random variables in <code>m</code> can be redefined using the <a href="api.html#FlexJuMP.setmean"><code>setmean</code></a> method where the new means are passed as a vector in the second argument.</p><pre><code class="language-">setmean(m, [1; 1; 1; 1])</code></pre><p>Note that the new means vector must match the length of the current means vector, otherwise calling <code>setmean</code> will throw an error. We will reset means back to their original values before continuing.</p><pre><code class="language-">setmean(m, means)</code></pre><p>As discussed in the <a href="background.html#Uncertainty-Set-Characterization-1">Uncertainty Set Characterization</a>) section, it is critical that the means correspond to a feasible instance of the random variables. The feasibility of the means can be tested with the <a href="api.html#FlexJuMP.ismeanfeasible"><code>ismeanfeasible</code></a> function. This tests the feasibility of the current mean for <code>m</code> using the feasibility function and returns <code>true</code> if it is feasible or <code>false</code> otherwise. In our current example we have</p><pre><code class="language-">result = ismeanfeasible(m)</code></pre><p>Thus, our current mean is feasible. By default the <code>ClpSolver</code> is used, but the keyword <code>solver</code> can be used to assign another solver LP or NLP solver.</p><p>Finally, the <a href="api.html#FlexJuMP.findcenteredmean"><code>findcenteredmean</code></a> function can be used to compute the analytic center or feasible center (which are described in <a href="background.html#Uncertainty-Set-Characterization-1">Uncertainty Set Characterization</a>). This function returns the feasible center by default, but can be changed via the <code>center::Symbol</code> keyword parameter where <code>:feasible</code> denotes the feasible center and <code>:analytic</code> refers to the analytic center. In our current example we have</p><pre><code class="language-">centered_mean = findcenteredmean(m, center = :analytic)</code></pre><p>This center can be used to replace the mean by setting the <code>update_mean::Bool</code> keyword parameter to <code>true</code>. Optionally, center can be constrained to be strictly positive with the <code>only_positive:Bool</code> keyword parameter. The default solver is the <code>IpoptSolver</code> since an NLP solver is required for the analytic center, but an LP solver can be used to compute the feasible center.</p><h3><a class="nav-anchor" id="Covariance-Extraction/Manipulation-1" href="#Covariance-Extraction/Manipulation-1">Covariance Extraction/Manipulation</a></h3><p>The covariance matrix stored in <code>m</code> can be extracted via the <a href="api.html#FlexJuMP.getcovariance"><code>getcovariance</code></a> method.</p><pre><code class="language-">covar = getcovariance(m)</code></pre><p>The covariance matrix can be set or changed using the <a href="api.html#FlexJuMP.setcovariance"><code>setcovariance</code></a> function which requires the second argument to be <code>covariance::Matrix</code>.</p><pre><code class="language-">setcovariance(m, covar)</code></pre><p>Note that the specified covariance must be symmetric positive semi-definite, otherwise <code>setcovariance</code> will throw an error. Also, it is important that the covariance matrix appropriately match the number of random variables in <code>m</code>.</p><h2><a class="nav-anchor" id="Model-Solution-1" href="#Model-Solution-1">Model Solution</a></h2><p>Now that the flexibility model <code>m</code> is defined we can solve it (i.e., solve the flexibility index problem). This is done simply by calling the JuMP <code>solve</code> function associated with the model. Thus, for our current example we have</p><pre><code class="language-">solve(m, active_constr = true)</code></pre><p>A number of keyword arguments can be passed which are each described in the documentation for <a href="api.html#FlexJuMP.solvehook"><code>solvehook</code></a>. Here the <code>active_constr::Bool</code> keyword argument is used to turn on the active constraint which enforces the number of active constraints at the solution (this is can be used for systems with linearly independent inequalities). The <code>U::Number</code> keyword argument specifies the slack upper bound which can be changed to improve the solution time for a particular problem. Also, the <code>conic_δ::Bool</code> keyword argument can be used to when an MICP solver is used such as <a href="https://github.com/JuliaOpt/Pajarito.jl">Pajarito.jl</a>.</p><h2><a class="nav-anchor" id="Post-Solution-Methods-1" href="#Post-Solution-Methods-1">Post-Solution Methods</a></h2><h3><a class="nav-anchor" id="Critical-Point-Extraction-1" href="#Critical-Point-Extraction-1">Critical Point Extraction</a></h3><p>Now that <code>m</code> is solved, the optimized values of the variables can be extracted with the <code>getvalue</code> method as is normally done with JuMP models. With the current example we have</p><pre><code class="language-">temperatures = getvalue(T)
cooling = getvalue(Qc)
state = getvalue(x)</code></pre><p>Note that this can be done with single variables and/or arrays of variables.</p><h3><a class="nav-anchor" id="Flexibility-Index-Information-1" href="#Flexibility-Index-Information-1">Flexibility Index Information</a></h3><p>The optimized value of the flexibility index stored in <code>m</code> can now be retrieved by using the <a href="api.html#FlexJuMP.getflexibilityindex"><code>getflexibilityindex</code></a> method.</p><pre><code class="language-">flexibility_index = getflexibilityindex(m)</code></pre><p>Similarly, the stored flexibility index can be used to obtain the confidence level if an ellipsoidal uncertainty set was used. This can be calculated using the <a href="api.html#FlexJuMP.getconfidencelevel"><code>getconfidencelevel</code></a> function.</p><pre><code class="language-">conf_lvl = getconfidencelevel(m)</code></pre><p>As discussed in the <a href="background.html#Uncertainty-Set-Characterization-1">Uncertainty Set Characterization</a> section, the confidence level provides a lower bound on the stochastic flexibility index.</p><p>The indexes of the active constraints can be obtained via the <a href="api.html#FlexJuMP.getactiveconstraints"><code>getactiveconstraints</code></a> method.</p><pre><code class="language-">actives = getactiveconstraints(m)</code></pre><p>If desired, we can also directly extract all of the flexibility data associated with the <a href="api.html#FlexJuMP.FlexibilityData"><code>FlexibilityData</code></a> type.</p><pre><code class="language-">data = getflexibilitydata(m)</code></pre><h2><a class="nav-anchor" id="Analysis-Methods-1" href="#Analysis-Methods-1">Analysis Methods</a></h2><h3><a class="nav-anchor" id="Ranking-Limiting-Constraints-1" href="#Ranking-Limiting-Constraints-1">Ranking Limiting Constraints</a></h3><p>In the <a href="background.html#Analysis-Techniques-1">Analysis Techniques</a> section we discussed how the flexibility index problem can be used to rank inequality constraints that most limit system flexibility. This can be done automatically using the [<code>rankinequalities</code>] function for a flexibility model <code>m</code>. This will return a vector of type <code>Vector{Dict}</code> where each dictionary contains the flexibility index, active constraint indexes, and optimized flexibility model corresponding to a particular rank level. With the current example we obtain</p><pre><code class="language-">rank_data = rankinequalities(m, max_ranks = 3, active_constr = true)</code></pre><p>The keyword argument <code>max_ranks::Int = 5</code> specifies the maximum number of rank levels, and the <code>m</code> will be iteratively solved without the previous active constraints until the maximum number of ranks is accomplished or the problem becomes unbounded, whichever occurs first. We also note that all of the same keyword arguments available to the <code>solve</code> function are accessible here since <code>rankinequalities</code> is a wrapper function for <code>solve</code>.</p><h3><a class="nav-anchor" id="Stochastic-Flexibility-Index-1" href="#Stochastic-Flexibility-Index-1">Stochastic Flexibility Index</a></h3><p>The stochastic flexibility index can be computed via Monte Carlo sampling using the <a href="api.html#FlexJuMP.findstochasticflexibility"><code>findstochasticflexibility</code></a> function. The number of samples can be specified with the <code>num_pts::Int = 10000</code> keyword argument.</p><pre><code class="language-">SF = findstochasticflexibility(m, num_pts = 100, use_vulnerability_model = true)</code></pre><p>By default each sample is evaluated individually, but all of them can be evaluated simultaneously by setting the <code>use_vulnerability_model::Bool</code> to <code>true</code> as explained in <a href="background.html#Stochastic-Flexibility-Index-Problem-1">Stochastic Flexibility Index Problem</a>. Furthermore, the <code>use_flexibility_index::Bool = false</code> keyword argument can be set to <code>true</code> to use the optimized uncertainty set to reduce the number of MC samples that need to be evaluated. The <code>only_positive::Bool = false</code> keyword argument enforces that only positive MC samples are used.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>By default the <code>ClpSolver</code> is used, but other solvers that support warm starts such as Gurobi and Cplex will improve performance if <code>use_vulnerability_model::Bool = false</code>. The solver can be changed with the <code>solver</code> keyword argument. </p></div></div><footer><hr/><a class="previous" href="background.html"><span class="direction">Previous</span><span class="title">Background</span></a><a class="next" href="examples.html"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
